package com.example.crossds.controller;

import com.example.crossds.model.*;
import com.example.crossds.repository.*;
import com.example.crossds.service.Credentials;
import com.example.crossds.service.genericapi.GenericApiService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@org.springframework.stereotype.Controller // This means that this class is a Controller
@RequestMapping(path="/playlist") // This means URL's start with /demo (after Application path)
@CrossOrigin
public class PlaylistController extends MainController {

    private Logger logger = LoggerFactory.getLogger(PlaylistController.class);

    // TODO : remove all repository other than PlaylistRepository
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AccountRepository accountRepository;

    @Autowired
    private AccountPlaylistRepository accountPlaylistRepository;

    @Autowired
    private CollaborativePlaylistRepository collaborativePlaylistRepository;

    @Autowired
    private TrackRepository trackRepository;

    @Autowired
    private PlaylistRepository playlistRepository;

    @Autowired
    private UserController userController;

    @Autowired
    private TrackController trackController;



    @PostMapping(path="/{title}") // Map ONLY POST Requests
    public @ResponseBody Boolean createNewPlaylist (@PathVariable String title , @RequestBody List<Long> ids) {
        List<Account> accounts = accountRepository.findAllById(ids);

        CollaborativePlaylist collaborativePlaylist = new CollaborativePlaylist();
        collaborativePlaylist.setName(title);

        //pour chaque compte
        //  creation de la playlist sur la plateforme
        //  Objtenir l'id de la dite playlist
        //  Creation de l'account playlist + id playlist + account + collaborative playlist
        //save collaborative playlist

        for (Account account: accounts) {

            ApiResponseWrapper<String> id = getApiServiceFor(account).createPlaylist(account.getCredentials(), account.getUsername(), title);

            AccountPlaylist accountPlaylist = new AccountPlaylist();
            accountPlaylist.setService_playlist_id(id.getData());
            accountPlaylist.setCollaborativePlaylist(collaborativePlaylist);
            accountPlaylist.setAccount(account);
            accountPlaylistRepository.save(accountPlaylist);

            // The credentials have to be updated if changed
            Account tmp = new Account(account);
            tmp.setCredentials(id.getCredentials());
            accountRepository.save(tmp);
        }

        //if we get there, then the creation was a success
        return true;
    }

    @PostMapping(path="/update/{id}")
    public @ResponseBody boolean updateOne(@PathVariable Long id){


        //Part 1 - Update all new songs in to DB
        //Step 1.1 - Check which remote playlist were changed (snapshotHash)
        //Step 1.2 - Get All songs from those changed
        //Step 1.3 - Add all new Tracks in db

        //Part 2 - Update each remote playlist
        //Step 2.1 - All tracks from db not in remote playlist are appended to the add List

        Optional<CollaborativePlaylist> optionalCollaborativePlaylist = collaborativePlaylistRepository.findById(id);
        if(optionalCollaborativePlaylist.isPresent()) {
            CollaborativePlaylist collaborativePlaylist = optionalCollaborativePlaylist.get();

            //Part 1 - Update all new songs in to DB
            //get common tracks
            Set<Track> storedCommonTracks = collaborativePlaylist.getTracks();
            // for each platform
            Set<AccountPlaylist> accountPlaylists = collaborativePlaylist.getAccountPlaylists();
            for (AccountPlaylist ap : accountPlaylists) {
                //  get distant tracks
                ApiResponseWrapper<Set<Track>> distantTracks = getApiService(ap.getAccount().getPlatform())
                        .getPlaylistTracks(ap.getAccount().getCredentials(), ap.getService_playlist_id());
                //  only keep new tracks
                distantTracks.getData().removeAll(storedCommonTracks);
                //  for each track left :
                for (Track track: distantTracks.getData()) {
                    // get identifier for other platforms
                    Track newTrack = getAlternativeIdentifier(track);
                    trackRepository.save(newTrack);
                    storedCommonTracks.add(newTrack);

                }
            }
            collaborativePlaylist.setTracks(storedCommonTracks);
            collaborativePlaylistRepository.save(collaborativePlaylist);

            //Part 2

            Set<AccountPlaylist> updatesAP = new HashSet<>();
            Set<Account> updatesA = new HashSet<>();
            for (AccountPlaylist accountPlaylist : accountPlaylists) {
                Set<Track> newTracksToAdd = new HashSet<>(storedCommonTracks);
                Account modifyAccount = new Account(accountPlaylist.getAccount());
                AccountPlaylist modifyAccountPlaylist = new AccountPlaylist(accountPlaylist);

                Platform platform = accountPlaylist.getAccount().getPlatform();
                Credentials credentials = accountPlaylist.getAccount().getCredentials();
                String playlistId = accountPlaylist.getService_playlist_id();

                //Step 2.1
                // get new tracks for this account and create a list of its ids
                ApiResponseWrapper<Set<Track>> distantTracks = getApiService(platform).getPlaylistTracks(credentials, playlistId);
                credentials = distantTracks.getCredentials();

                //only add new tracks not in distant playlist
                newTracksToAdd.removeAll(distantTracks.getData());

                if(newTracksToAdd.size()>0){
                    List<String> tracksIds = newTracksToAdd.stream().map(track -> {
                        if(platform.equals(Platform.SPOTIFY) && track.isSpotify_availability()){
                            return track.getSpotify_identifier();
                        }
                        if(platform.equals(Platform.DEEZER) && track.isDeezer_availability()){
                            return track.getDeezer_identifier();
                        }
                        return null;
                    }).filter(Objects::nonNull).collect(Collectors.toList());

                    if(tracksIds.size()>0){
                        ApiResponseWrapper<String> response = getApiService(platform).addTracksToPlaylist(credentials, playlistId, tracksIds);
                        credentials = response.getCredentials();
                        modifyAccountPlaylist.setSnapshotHash(response.getData());
                    }
                }

                //save account's credentials
                modifyAccount.setCredentials(credentials);
                accountRepository.save(modifyAccount);

                //add modified accountPlaylist to the update list
                updatesAP.add(modifyAccountPlaylist);
            }

            updatesAP.forEach((ap)->{
                accountPlaylistRepository.save(ap);
            });
        }else{
            return false;
        }
        return true;
    }

    @PostMapping(path="/update")
    @Scheduled(fixedRate = 3600000) //Every hour
    public @ResponseBody void updateAll(){

        logger.info("Function : updateAll");

        Iterable<CollaborativePlaylist> collaborativePlaylists = collaborativePlaylistRepository.findAll();
        for (CollaborativePlaylist collaborativePlaylist : collaborativePlaylists) {
            updateOne(collaborativePlaylist.getId_playlist());
        }
    }

    @GetMapping(path = "/{id}")
    public @ResponseBody void getPlaylist(@PathVariable Long id){

        ////TODO: implement
        Optional<CollaborativePlaylist> optionalCollaborativePlaylist = collaborativePlaylistRepository.findById(id);
    }


    private Track getAlternativeIdentifier(Track track){
        Track newTrack = new Track(track);
        if(!track.hasServiceIdentifier(Platform.SPOTIFY)){
            //Track localTrack = newTracks.
            String id = getApiService(Platform.SPOTIFY).getServiceIdentifierBasedOnIsrc(track.getIsrc());
            if(id==null){
                newTrack.setSpotify_availability(false);
            }{
                newTrack.setSpotify_identifier(id);
                newTrack.setSpotify_availability(true);
            }
        }else{
            newTrack.setSpotify_availability(true);
        }

        if(!track.hasServiceIdentifier(Platform.DEEZER)){
            //Track localTrack = newTracks.
            String id = getApiService(Platform.DEEZER).getServiceIdentifierBasedOnIsrc(track.getIsrc());
            if(id==null){
                newTrack.setDeezer_availability(false);
            }{
                newTrack.setDeezer_identifier(id);
                newTrack.setDeezer_availability(true);
            }
        }else{
            newTrack.setDeezer_availability(true);
        }
        return newTrack;
    }

    /**
     *
     * @param platform
     * @param storedTracks
     * @param remotePlaylistTracks
     * @return
     */
    private List<String> getNewTracksIds(Platform platform, Set<Track> storedTracks, Set<Track> remotePlaylistTracks) {
        List<Track> tracksToAdd = new ArrayList<>(storedTracks);
        tracksToAdd.removeAll(remotePlaylistTracks);

        List<String> tracksIds = new ArrayList<>();

        tracksIds = tracksToAdd.stream().map(track -> {
            if(platform.equals(Platform.SPOTIFY) && track.isSpotify_availability()){
                return track.getSpotify_identifier();
            }
            if(platform.equals(Platform.DEEZER) && track.isDeezer_availability()){
                return track.getDeezer_identifier();
            }
            return null;
        }).collect(Collectors.toList());

        return tracksIds;
    }

    /**
     * Given the name and the user it is attached to, create a playlist for the user
     * @param name the playlist name
     * @param user_id the user id
     * @return the new playlist
     */
    public Playlist createPlaylist(String name, Long user_id) {
        User user = userController.getUser(user_id);
        GenericApiService service = getApiService(user.getPlatform());

        String access_token = userController.updateToken(user);
        String playlistId = service.createPlaylist(access_token, user.getUsername(), name);
        logger.info("API CALL : "+ user.getPlatform().getName()+" -> createPlaylist");

        Playlist playlist = getPlaylistInfo(user, playlistId);

        playlist.setOwner(user);

        playlistRepository.save(playlist);

        return playlist;
    }

    /**
     * Gets either the playlist in db OR
     *      if the playlist isn't yet in db, get it on the platform and save it in db
     *      returns the playlist either way
     * @param user the user
     * @param playlistPlatformId the playlist id on the platform
     * @return the playlist
     */
    public Playlist getPlaylistInfo(User user, String playlistPlatformId) {
        Playlist playlist;
        // try to see if the playlist already exists
        Optional<Playlist> opt = playlistRepository.findPlaylistByPlatform_idAAndOwnerId(playlistPlatformId, user.getId());
        //if exists, return it, else fetch it
        playlist = opt.orElseGet(() -> fetchPlaylistInfo(user, playlistPlatformId));
        return playlist;
    }

    /**
     * Fetch playlist info from the platform
     * @param user the user
     * @param playlistPlatformId the playlist id on the platform
     * @return the playlist
     */
    public Playlist fetchPlaylistInfo(User user, String playlistPlatformId) {
        String access_token = userController.updateToken(user);
        Playlist remote = getApiService(user.getPlatform()).getPlaylistInfo(access_token, playlistPlatformId);
        logger.info("API CALL : "+ user.getPlatform().getName()+" -> getRemotePlaylistInfo");
        return remote;
    }

    /**
     * Returns whether or not a playlist was modified remotely
     * @param playlist
     * @return
     */
    public boolean hasChanged(Playlist playlist) {
        Playlist remote = fetchPlaylistInfo(playlist.getOwner(), playlist.getPlatform_id());
        return !playlist.getSnapshot_hash().equals(remote.getSnapshot_hash());
    }

    public Set<Track> fetchTracks(User user, String playlistPlatformId) {
        String access_token = userController.updateToken(user);
        Set<Track> tracks = getApiService(user.getPlatform()).getPlaylistTracks(access_token, playlistPlatformId);
        logger.info("API CALL : "+ user.getPlatform().getName()+" -> fetchTracks");
        return tracks;
    }
}
